#!/usr/bin/env python

from Crypto.Util.number import inverse
from Crypto.PublicKey.RSA import construct

# Given a private key, we can extract n and e (the modulus and exponent).
# (openssl rsa -pubin -modulus -in pub.key)
n = 573177824579630911668469272712547865443556654086190104722795509756891670023259031275433509121481030331598569379383505928315495462888788593695945321417676298471525243254143375622365552296949413920679290535717172319562064308937342567483690486592868352763021360051776130919666984258847567032959931761686072492923
e = 68180928631284147212820507192605734632035524131139938618069575375591806315288775310503696874509130847529572462608728019290710149661300246138036579342079580434777344111245495187927881132138357958744974243365962204835089753987667395511682829391276714359582055290140617797814443530797154040685978229936907206605

# q and p are prime factors of n, and come from a factor database like http://www.factordb.com/
q = 20423438101489158688419303567277343858734758547418158024698288475832952556286241362315755217906372987360487170945062468605428809604025093949866146482515539
p = 28064707897434668850640509471577294090270496538072109622258544167653888581330848582140666982973481448008792075646342219560082338772652988896389532152684857

# Now, we work out the Euler's totient
phin = (p-1) * (q-1)

# Find the inverse of e within the totient
d = inverse(e, phin)

# Construct a private key, and print it out
key = construct((n, e, d, q, p))
print(key.export_key().decode('ascii'))

# And you can then use openssl to decrypt
# (openssl rsautl -decrypt -inkey private.key -in text.enc)
